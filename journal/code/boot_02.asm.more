bits 16                     ; we are in 16 bit real mode
org 0x7c00                  ; origin of our code

; offset of code segment and data segemnt from gdt start
CODE_OFFSET equ 0x8         ; code segment descriptor in gdt start
DATA_OFFSET equ 0x10        ; data segment descriptor in gdt start

start:
    cli                     ; clear interrupts
    ; mov ax, 0x00            ; clear ax (xor ax, ax) more efficient
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7c00          ; set stack pointer
    sti                     ; enable interrupts back ( so the above code will executes with no interrupts)

load_PM:
    cli                     ; clear intrrupts
    lgdt [gdt_descriptor]   ; load gdt 

    ; enable protected mode
    mov eax, cr0            ; set one bit in control register (or bit called protected mode enabled) or al, 1
    or al, 1                ; setting the lower part of eax to 1 (set protection enable bit)
    mov cr0, eax            ; now cr0 has protection mode enabled

    ; Far jump to flush pipeline and load CS with CODE_OFFSET
    jmp CODE_OFFSET:PModeMain

; Null descriptor at 0x00
; Code segment at 0x08: Execute/Read, DPL=0, 32-bit, 4GB limit
; Data segment at 0x10: Read/Write, DPL=0, 32-bit, 4GB limit

; GDT table 
gdt_start:
    ; null descriptor
    ;dd 0x0                  ; 0000
    ;dd 0x0                  ; 0000
    dq 0x0                  ; 1st entry must be null (8 bytes)  (0000 0000)

    ; code segment deasciptor (0x8)
    dw 0xFFFF               ; limit 
    dw 0x0000               ; base
    db 0x00                 ; base
    db 10011010b            ; Access bytes b=binary
    ; Access bytes
    ; present bit: must be set to 1 for any valid segment 
    ; DPL(need 2bits: 0 = highest(kernal) 1 = lowest(user application)
    ; S(descriptor type bit): 0 = system segment 1 = data or code segment
    ; E(executable bit): 0 = data segment 1 = code segment 
    ; DC(Direcion bit/conformint bit) = we are defining code segment (0)
    ; RW(Redable/Writable): code segemnt readable bit 1
    ; access bit = 0
    db 11001111b            ; defining 32-bit segments
    db 0x00                 ; base

    ; data segment deasciptor (0x10)
    dw 0xFFFF               ; limit 
    dw 0x0000               ; base
    db 0x00                 ; base
    db 10010010b            ; change dc to directiob bit 0
    db 11001111b            ; 
    db 0x00                 ; base

gdt_end:
    
gdt_descriptor:
    dw gdt_end - gdt_start - 1  ; size of gdt - 1
    dd gdt_start                ; base address of gdt

bits 32
PModeMain:
    ; Initialize segment registers with data segment selector
    mov ax, DATA_OFFSET
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov ss, ax
    mov gs, ax

    ; set up stack
    mov ebp, 0x9C00 ; in protected mode we have much more memory 
                    ; we are setting the stack one more time
                    ; we need to find our location memory far enough 
                    ; that our satck will not overflow the bootloader code and other impt stuff
                    ; 0x9c00 is the space btween 0x7c00
    mov esp, ebp

    ; a20 address line is a physical representation of 1st 21's bytes
    ; address memory beyond 1mb
    in al, 0x92
    or al, 2
    out 0x92, al

    mov edi, 0xB8000          ; video memory address
    mov ah, 0x0F              ; white on black
    mov al, 'P'               ; character to display
    mov [edi], ax

    jmp $           ; infinite jump
    

times 510 - ($ - $$) db 0
dw 0xAA55
