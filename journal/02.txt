mon 15 dec 2025

Goal:
    - get the dev enviroment 
    - some coding 

Dev enviroment 
- unix like os      // linux or mac
- gcc or clang      // c compiler
- nasm or fasm      // assmebler
- ld                // linker
- qemu or bochs     // emulator (bochs has a better debugger)
- dd,fdisk
- hex editor
- xorriso           // creating iso image
- grub              // bootloader

- Idk how many of the above thing are going to be used,
- as u know its a mf*n journal

> ok so what now (idk).. 
- so power btn pressed > electricity flows
- BIOS/UEFI (tiny program buit into motherboard) wakes up
- BIOS/UEFI looks for a bootloader on ur drive
- bootloader finds and loads ur OS kernal
- kernal loads the rest of the OS

OK so thats what it is UMMMM
- so BIOS vs UEFI 
    BIOS: old simple starts in 16bit mode 
    UEFI: New fancy starts in 64-bit mode birectly

- Bootloader 
    - grub (linux use this)
    - its 512 bytes 

- kernal 
    - for now its a wet dream!!

So whats the plan tough chouice??
- BIOS for hardcore and biased reasons come on u know me 
- Grubbb lol we will write our own bootloader come on grub is too bloated 

> ok so we are going to start from bootloader 
> if ur wonder WHHY not BIOS cause its fitted in ur motherboard

> boot.asm    
bits 16             ; we are running in real mode
org 0x7c00          ; bios loads code at this address

mov si, 0

print:
    mov ah, 0x0e
    mov al, [hello + si]
    int 0x10
    add si, 1
    cmp [hello + si], 0
    jne print 

hello:
    db "hello world!", 0

times 510 - ($ - $$) db 0
dw 0xAA55

bash:
$ nasm -f bin boot.asm -o boot.bin

bits 16
- tells the assembler to generate 16-bit code in real mode 
- real mode (which is where BIOS loads boot sectors), 
- the processor operates in 16-bit mode
- All registers are 16-bit (AX, BX, CX, DX, SI, DI, etc.)
- Memory addresses are limited to 1MB (20-bit addressing via segment:offset)

org 0x7c00
- tells the assembler where in memory this code will be loaded
- The BIOS always loads boot sectors to address 0x7c00 in RAM
- All address calculations in the code will be offset from this base address
- Without this, label addresses (like hello) would be calculated incorrectly

times 510 - ($ - $$) db 0
- $ = current position in the output
- $$ = start of the section (0 for boot sectors)
- $ - $$ = bytes written so far
- 510 - ($ - $$) = bytes needed to reach position 510
- Fills remaining space with zeros (0x00 bytes)

dw 0xAA55
- Boot signature (magic number) at bytes 511-512
- BIOS checks for these two bytes to identify a valid boot sector
- Must be exactly: 0x55 0xAA (in little-endian order)
- dw 0xAA55 assembles as: byte 511 = 0x55, byte 512 = 0xAA

Little-Endian Explanation
- dw 0xAA55 means "define word" (16-bit value)
- In memory (little-endian x86): lower byte first
     Address 511: 0x55
     Address 512: 0xAA
- When read as a 16-bit word at address 511: 0xAA55

* BIOS loads 512 bytes from boot device to 0x7c00
* BIOS checks last 2 bytes = 0x55AA (as a 16-bit word)
* BIOS jumps to 0x7c00 (start of your code)
* Your code clears screen (int 0x10, function 0x03)
* Prints "hello world!" character by character
* Infinite loop (no halt instruction shown, would typically hang or loop)
